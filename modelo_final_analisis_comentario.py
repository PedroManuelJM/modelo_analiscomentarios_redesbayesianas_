# -*- coding: utf-8 -*-
"""MODELO_FINAL_ANALISIS_COMENTARIO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1smxA9nbxq0oW2uthFmNghQUNn8GsAnY2
"""

import nltk
nltk.download('punkt')

import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score  # Importar validación cruzada
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import ComplementNB
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix
from sklearn.preprocessing import LabelEncoder
import joblib
import nltk
from nltk.corpus import stopwords
from nltk.stem import SnowballStemmer
import re

# Ruta del dataset rebalanceado
dataset_path = "Comentarios_Licores_Rebalanceado.xlsx"

# 1. Cargar el dataset rebalanceado
print("Cargando el dataset desde", dataset_path)
data = pd.read_excel(dataset_path)

# 2. Preprocesamiento avanzado
print("Iniciando el preprocesamiento del dataset")
data = data[['Comentario', 'Etiqueta']]  # Seleccionar columnas necesarias  # Seleccionar columnas necesarias

# Mapear etiquetas a valores numéricos usando LabelEncoder
label_encoder = LabelEncoder()
data['Etiqueta'] = label_encoder.fit_transform(data['Etiqueta'])
print("Clases asignadas:", list(label_encoder.classes_))

# Verificar distribución de clases
print("Distribución de clases en el conjunto de datos original:")
print(data['Etiqueta'].value_counts())

# 3. Dividir datos en entrenamiento y prueba con estratificación
print("Dividiendo los datos en entrenamiento y prueba")
X_train, X_test, y_train, y_test = train_test_split(
    data['Comentario'], data['Etiqueta'], test_size=0.2, random_state=42, stratify=data['Etiqueta']
)

# Verificar distribución de clases después de la división
print("Distribución de clases en el conjunto de entrenamiento:")
print(y_train.value_counts())

print("Distribución de clases en el conjunto de prueba:")
print(y_test.value_counts())

# 4. Preprocesamiento de texto
nltk.download('stopwords')
spanish_stopwords = stopwords.words('spanish')
stemmer = SnowballStemmer('spanish')
negation_words = ['no', 'nunca', 'jamás', 'ni']

def preprocess_text(text):
    negation_flag = False
    # Convertir a minúsculas
    text = text.lower()
    # Eliminar caracteres especiales y números
    text = re.sub(r'[^a-záéíóúñü]', ' ', text)
    # Tokenizar
    tokens = text.split()
    # Eliminar stopwords y aplicar stemming
    processed_tokens = []
    for i, word in enumerate(tokens):
        if word in negation_words:
            negation_flag = True
        elif negation_flag:
            processed_tokens.append('no_' + word)  # Marcar la negación
        elif word in negation_words:
            processed_tokens.append(word)  # Mantener las palabras negativas
            negation_flag = False
        elif word not in spanish_stopwords:
            processed_tokens.append(stemmer.stem(word))
        # Asegurar que la palabra negativa se mantenga
        elif word in negation_words:
            processed_tokens.append(word)
    tokens = processed_tokens
    # Unir tokens
    text = ' '.join(tokens)
    return text

X_train = X_train.apply(preprocess_text)
X_test = X_test.apply(preprocess_text)

# 5. Vectorización con TF-IDF
print("Iniciando la vectorización de los comentarios con TF-IDF")
vectorizer = TfidfVectorizer(max_features=5000, ngram_range=(1, 2), min_df=5, max_df=0.7)
X_train_tfidf = vectorizer.fit_transform(X_train)
X_test_tfidf = vectorizer.transform(X_test)

print("Vectorización completada. Número de características:", len(vectorizer.get_feature_names_out()))

# Ajuste del modelo para mejores resultados con frases ambiguas
# 6. Entrenamiento del modelo
print("Entrenando el modelo de Naive Bayes")
model = ComplementNB(alpha=0.1)
model.fit(X_train_tfidf, y_train)

# Guardar el modelo, el vectorizador y el label encoder juntos
componentes = {
    "modelo": model,
    "vectorizador": vectorizer,
    "label_encoder": label_encoder
}
joblib.dump(componentes, "modelo_completo.pkl")

# 7. Evaluación del modelo
print("Evaluación con validación cruzada")
cross_val_scores = cross_val_score(model, X_train_tfidf, y_train, cv=5, scoring='accuracy')
print("Puntajes de validación cruzada:", cross_val_scores)
print("Promedio de validación cruzada:", cross_val_scores.mean())

print("Evaluando el modelo en el conjunto de prueba")
y_pred = model.predict(X_test_tfidf)

print("Reporte de Clasificación:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))
precision = accuracy_score(y_test, y_pred)
print("Precisión del modelo:", precision)
print("Exactitud del Modelo en Prueba:", accuracy_score(y_test, y_pred))

# Mostrar matriz de confusión en consola
cm = confusion_matrix(y_test, y_pred)
print("Matriz de confusión:")
print(cm)

# 8. Predicción de nuevos comentarios
def predecir_nuevos_comentarios(nuevos_comentarios):
    # Cargar el modelo, vectorizador y label encoder juntos
    componentes = joblib.load("modelo_completo.pkl")
    model = componentes["modelo"]
    vectorizer = componentes["vectorizador"]
    label_encoder = componentes["label_encoder"]

    # Preprocesar nuevos comentarios
    nuevos_comentarios_prep = [preprocess_text(comentario) for comentario in nuevos_comentarios]

    nuevos_comentarios_tfidf = vectorizer.transform(nuevos_comentarios_prep)
    predicciones = model.predict(nuevos_comentarios_tfidf)

    # Obtener etiquetas originales
    predicciones_etiquetas = label_encoder.inverse_transform(predicciones)

    # Mostrar resultados
    for comentario, etiqueta in zip(nuevos_comentarios, predicciones_etiquetas):
        print(f"Comentario: {comentario} | Sentimiento: {etiqueta}")

# Ejemplo de nuevos comentarios a predecir
nuevos_comentarios = [
    "El producto llegó a tiempo y en excelentes condiciones, lo recomiendo ampliamente.",
    "No tiene buen sabor, esperaba mucho más por el precio que pagué.",
    "Es simplemente perfecto, ideal para reuniones con amigos o familiares.",
    "El empaque llegó dañado, pero el producto en sí estaba bien.",
    "No es malo, pero tampoco es algo que volvería a comprar.",
    "No cumplió con mis expectativas, no lo recomendaría.",
    "El sabor fue excelente, todos en la fiesta quedaron impresionados.",
    "Esperaba más del producto, no estuvo a la altura de mis expectativas.",
    "Muy buen servicio y el licor de alta calidad, repetiré la compra.",
    "No me gustó para nada, decepcionante y no lo recomendaría."
]

predecir_nuevos_comentarios(nuevos_comentarios)